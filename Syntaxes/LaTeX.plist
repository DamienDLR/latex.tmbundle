{
    fileTypes = (tex); 
    firstLineMatch = "^\\\\documentclass.*"; 
    foldingStartMarker = "\\\\begin\\{.*\\}"; 
    foldingStopMarker = "\\\\end\\{.*\\}"; 
    keyEquivalent = "~^L"; 
    name = LaTeX; 
    patterns = (
        {   name = "string.other.match.block.latex"; 
            begin = "\\$\\$"; end = "\\$\\$"; 
        }, 
        {match = "[\\[\\]\\{\\}]"; name = "keyword.operator.braces.latex"; }, 
        {match = "\\\\\\\\"; name = "keyword.operator.newline.latex"; }, 
        {
            begin = "((\\\\(?:(?:sub)*section|chapter|paragraph|part))(\\*?)(?:(\\[)[^\\[]*?(\\]))??(\\{))"; 
            captures = {
                1 = {name = "support.function.section.latex"; }; 
            }; 
            end = "(\\})"; 
            name = "declaration.section.latex"; 
            patterns = ({match = "[^}]+"; name = "variable.parameter.section.latex"; }); 
        }, 
        {
            begin = "(\\\\begin\\{)(lstlisting)(\\})(\\[(.*)\\])?"; 
            captures = {
                1 = {name = "support.function.latex"; }; 
                2 = {name = "variable.parameter.latex"; }; 
                3 = {name = "support.function.latex"; }; 
                4 = {name = "support.function.latex"; }; 
            }; 
            comment = "Put the lstlisting match before the more general environment listing. Someday it would be nice to make this rule general enough to figure out which language is inside the lstlisting environment rather than my own personal use for python. --Brad"; 
            end = "(\\\\end\\{)(lstlisting)(\\})"; 
            name = "source.python.embedded.latex"; 
            patterns = ({include = "source.python"; }); 
        }, 
        {
            begin = "^\\s*(\\\\begin\\{)(verbatim)(\\})"; 
            end = "^\\s*(\\\\end\\{)(verbatim)(\\})"; 
            name = "declaration.verbatim.latex"; 
            captures = {
                1 = {name = "support.function.latex"; }; 
                2 = {name = "variable.parameter.latex"; }; 
                3 = {name = "support.function.latex"; }; 
            }; 
        }, 
        {
            captures = {
                1 = {name = "support.function.latex"; }; 
                2 = {name = "variable.parameter.latex"; }; 
                3 = {name = "support.function.latex"; }; 
            }; 
            comment = "These two patterns match the \\begin{document} and \\end{document} commands, so that the environment matching pattern following them will ignore those commands."; 
            match = "(\\\\begin\\{)(document)(\\})"; 
            name = "declaration.begin-document.latex"; 
        }, 
        {
            captures = {
                1 = {name = "support.function.latex"; }; 
                2 = {name = "variable.parameter.latex"; }; 
                3 = {name = "support.function.latex"; }; 
            }; 
            match = "(\\\\end\\{)(document)(\\})"; 
            name = "declaration.end-document.latex"; 
        }, 
        {
            captures = {
                1 = {name = "support.function.latex"; }; 
                2 = {name = "variable.parameter.latex"; }; 
                3 = {name = "support.function.latex"; }; 
            }; 
            match = "(\\\\begin\\{)(enumerate|itemize|description|list)(\\})"; 
            name = "declaration.begin-list.latex"; 
        }, 
        {
            captures = {
                1 = {name = "support.function.latex"; }; 
                2 = {name = "variable.parameter.latex"; }; 
                3 = {name = "support.function.latex"; }; 
            }; 
            match = "(\\\\end\\{)(enumerate|itemize|description|list)(\\})"; 
            name = "declaration.end-list.latex"; 
        }, 
        {
            begin = "(\\\\begin\\{)(.*?)(\\})"; 
            captures = {
                1 = {name = "support.function.latex"; }; 
                2 = {name = "variable.parameter.latex"; }; 
                3 = {name = "support.function.latex"; }; 
            }; 
            comment = "As it is, this captures all begin-end blocks that are not \\begin{document}-\\end{document} blocks. It will further allow any text.latex pattern in the block to be matched."; 
            end = "(\\\\end\\{)(\\2)(\\})"; 
            name = "declaration.environment.latex"; 
            patterns = ({include = "text.latex"; }); 
        }, 
        {
            begin = "(\\\\textit\\{)"; 
            captures = {1 = {name = "support.function.textit.latex"; }; }; 
            comment = "We put the keyword in a capture and name this capture, so that disabling spell checking for “keyword” won't be inherited by the argument to \\textit{...}.\n\nPut specific matches for particular LaTeX keyword.functions before the last two more general functions"; 
            end = "(\\})"; 
            name = "declaration.textit.latex"; 
            patterns = ({match = "[^}]+"; name = "markup.italic.textit.latex"; }); 
        }, 
        {
            begin = "(\\\\textbf\\{)"; 
            captures = {1 = {name = "support.function.textbf.latex"; }; }; 
            end = "(\\})"; 
            name = "declaration.textbf.latex"; 
            patterns = ({match = "[^}]+"; name = "markup.bold.textbf.latex"; }); 
        }, 
        {
            begin = "(\\\\texttt\\{)"; 
            captures = {1 = {name = "support.function.texttt.latex"; }; }; 
            end = "(\\})"; 
            name = "declaration.texttt.latex"; 
            patterns = ({match = "[^}]+"; name = "markup.terminal.texttt.latex"; }); 
        }, 
        {
            captures = {1 = {name = "support.constant.item.latex"; }; }; 
            match = "(\\\\item)(.*)$"; 
            name = "declaration.item.latex"; 
        }, 
        {
            begin = "(\\\\cite(al)?[tp]?\\*?(\\[[^\\]]*\\]){,2}\\{)"; 
            captures = {1 = {name = "keyword.control.cite.latex"; }; }; 
            end = "(\\})"; 
            name = "declaration.cite.latex"; 
            patterns = ({match = "\\w+"; name = "variable.parameter.cite.latex"; }); 
        }, 
        {
            begin = "(\\\\(?:ref|eqref|label)\\{)"; 
            captures = {1 = {name = "keyword.control.ref-or-label.latex"; }; }; 
            end = "(\\})"; 
            name = "declaration.ref-or-label.latex"; 
            patterns = ({match = "[a-zA-Z,:0-9]+"; name = "variable.parameter.ref-or-latex.latex"; }); 
        }, 
        {
            begin = "(\\\\[A-Za-z]\\w*)(?=\\{|\\[)"; 
            captures = {1 = {name = "support.function.with-arg.latex"; }; }; 
            comment = "These next two are catch-all matches that will match almost any latex function. First match: \\foo{arg1}{arg2}{...}{argN}"; 
            end = "(?<=\\]|\\})"; 
            name = "declaration.function.with-arg.latex"; 
            patterns = (
                {
                    begin = "\\{"; 
                    end = "\\}"; 
                    patterns = ({match = "[^}]+"; name = "variable.parameter.function.latex"; }); 
                }, 
                {
                    begin = "\\["; 
                    end = "\\]"; 
                    patterns = ({match = "[^]]+"; name = "variable.parameter.function.latex"; }); 
                }
            ); 
        }, 
        {
            comment = "then match just: \\foo"; 
            match = "\\\\[A-Za-z]\\w*"; 
            name = "support.function.latex"; 
        }, 
        {begin = "``"; end = "''"; name = "string.quoted.single.latex"; }, 
        {
            begin = "(^|[^\\\\])\\$"; 
            end = "\\$"; 
            name = "string.other.math.latex"; 
        }, 
        {begin = "\\\\\\("; end = "\\\\\\)"; name = "string.other.math.latex"; }, 
        {
            begin = "\\\\\\["; 
            end = "\\\\\\]"; 
            name = "string.other.math.latex"; 
        }, 
        {
            comment = "Not sure if this is the proper classification. This is a catch-all for \\<symbol> so that e.g. \\\" doesn't start an (invalid) string"; 
            match = "\\\\[^A-Za-z\n]"; 
            name = "constant.character.escape.latex"; 
        }, 
        {match = "%.*$"; name = "comment.line.percentage.latex"; }
    ); 
    scopeName = "text.latex"; 
    uuid = "3BEEA00C-6B1D-11D9-B8AD-000D93589AF6"; 
}
