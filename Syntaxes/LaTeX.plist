{
    fileTypes = (tex); 
	firstLineMatch = "^\\\\documentclass.*";
    foldingStartMarker = "\\\\begin\\{.*\\}"; 
    foldingStopMarker = "\\\\end\\{.*\\}"; 
    name = Latex; 
    scopeName = "text.latex";
    keyEquivalent = "~^L";
    patterns = (
        {   name = "string.latex.equation.displaymath.$"; 
            begin = "\\$\\$"; end = "\\$\\$"; 
        }, 
        {   name = "keyword.operator.latex.braces"; 
            match = "[\\[\\]\\{\\}]"; 
        }, 
        {   name = "keyword.operator.latex.newline"; 
            match = "\\\\\\\\"; 
        }, 
        {   name = "declaration.section.latex";
            begin = "(\\\\(?:(?:sub)*section|chapter|paragraph|part))(\\*?)(\\[.*\\])?\\{"; end = "\\}"; 
            captures = {
                1 = { name = "keyword.function.section.latex"; };
            };
            patterns = (
                { match = "\\{[^{}\\n]*(?R)?[^{}\\n]*\\}"; name = "entity.parameter.function.section.latex"; },
                { match = "[^{}\\n]+"; name = "entity.parameter.function.section.latex"; }
            );
        },
        // Put the lstlisting match before the more general environment listing.
        // Someday it would be nice to make this rule general enough to figure out
        // which language is inside the lstlisting environment rather than my own personal
        // use for python. --Brad
        {   name = "source.python";
            begin = "(\\\\begin\\{)lstlisting(\\})(\\[(.*)\\])?"; 
            end = "(\\\\end\\{)lstlisting(\\})"; 
            captures = {
              1 = { name = "keyword.function.environment"; };
              2 = { name = "keyword.function.environment"; };
              //3 = { name = "entity.parameter.variable.function.latex.optional"; };              
              3 = { name = "keyword.function.environment"; };
              4 = { name = "keyword.function.environment"; };
            };
            patterns = ({ include = "source.python"; });
        },          
        // ideally these next two could be re-written as real begin end pairs 
        // so that one could do interesting things to the body of an environment.
        {   name = "declaration.begin.latex";
            match = "(\\\\begin\\{)(.*?)(\\})"; 
            captures = {
              1 = { name = "keyword.function.environment.latex"; };                
              2 = { name = "entity.parameter.function.variable.environment.latex"; };
              3 = { name = "keyword.function.environment.latex"; };                              
            };             
        },
        {   name = "declaration.end.latex";
            match = "(\\\\end\\{)(.*?)(\\})";
            captures = {
              1 = { name = "keyword.function.environment.latex"; };                
              2 = { name = "entity.parameter.function.variable.environment.latex"; };
              3 = { name = "keyword.function.environment.latex"; };                              
            };             
        }, 
        {   name = "declaration.textit.latex";
            // we put the keyword in a capture and name this capture, 
            // so that disabling spell checking for “keyword” won't be
            // inherited by the argument to \textit{...}
            
            // Put specific matches for particular LaTeX keyword.functions before the 
            // last two more general functions
            begin = "(\\\\textit\\{)";end = "(\\})";
            captures = { 1 = { name = "keyword.function.latex.textit"; }; }; 
            patterns = ( { match = "\\w+"; name = "markup.italic.textit.latex"; } );
        }, 
        {   name = "declaration.textbf.latex";
            begin = "(\\\\textbf\\{)"; end = "(\\})"; 
            captures = { 1 = { name = "keyword.function.latex.textbf"; }; }; 
            patterns = ( { match = "\\w+"; name = "markup.bold.textbf.latex"; } );
        }, 
        {   name = "declaration.texttt.latex";
            begin = "(\\\\texttt\\{)"; end = "(\\})"; 
            captures = { 1 = { name = "keyword.function.latex.texttt"; }; }; 
            patterns = ( { match = "\\w+"; name = "markup.terminal.texttt.latex"; } );
        }, 
        {   name = "declaration.cite.latex";
            begin = "(\\\\cite[tp]*\\{)"; end = "(\\})"; 
            captures = { 1 = { name = "keyword.control.latex.cite"; }; }; 
            patterns = ( { match = "\\w+"; name = "entity.parameter.function.variable.cite"; } );
        }, 
        {   name = "declaration.ref-or-label.latex";
            begin = "(\\\\(?:ref|label)\\{)"; end = "(\\})"; 
            captures = {
                1 = { name = "keyword.control.ref-or-label.latex"; };
            };
            patterns = (
                {
                    match = "[a-zA-Z,:0-9]+";
                    name = "entity.parameter.function.variable.ref";
                },
            );
        }, 
        // These next two are catch-all matches that
        // will match almost any latex function
        {   name = "declaration.function-with-arg.latex";
            // first match “\foo{arg}”
            begin = "(\\\\[A-Za-z]\\w*)\\{"; end = "\\}"; 
            captures = { 1 = { name = "keyword.function.with-arg.latex.general"; }; };
            patterns = (
                { match = "\\{[^{}\\n]*(?R)?[^{}\\n]*\\}"; name = "entity.parameter.function.variable"; },
                { match = "[^{}\\n]+"; name = "entity.parameter.function.variable"; }
            );
        }, 
        {   name = "keyword.function.latex.general";
            // then match just “\foo”
            match = "\\\\[A-Za-z]\\w*";
        }, 
        {   name = "string.single.latex"; 
            begin = "[`]+"; end = "[']+"; 
        }, 
        {   name = "string.latex.equation.linemath.$"; 
            begin = "(^|[^\\\\])\\$"; end = "\\$"; 
        }, 
        {   name = "string.latex.equation.linemath"; 
            begin = "\\\\\\("; end = "\\\\\\)"; 
        }, 
        {   name = "string.latex.equation.displaymath"; 
            begin = "\\\\\\["; end = "\\\\\\]"; 
        }, 
        {   name = "dummy.escape";
            // we catch escape followed by ws or end-of-line
            // so that we can change the behavior of the " key back
            // to normal quote instead of ``quote''.
            match = "\\\\(\\s|$)";
        }, 
        {   name = "constant.character"; // not sure if this is the proper classification
            // this is a catch-all for \<symbol> so
            // that e.g. \" doesn't start an (invalid) string
            match = "\\\\[^A-Za-z\n]";
        }, 
        {   name = "invalid.string.latex"; 
            begin = "\""; end = "\""; 
        }, 
        {   name = "comment.line.latex"; 
            match = "(^|[^\\\\])%.*$"; 
        }, 
    ); 
    smartTypingPairs = (("(", ")"), ("[", "]"), ("{", "}"), ("\"", "\""), ("$", "$"), ("`", "'")); 
    uuid = "3BEEA00C-6B1D-11D9-B8AD-000D93589AF6"; 
}
